##=============================================================================
## 4.d ========================================================================

# =============================================================================
# This functions implement 0,1 Knapsack algorithm using dynamic programming. 
# Fill an empty matrix, B, with the maximum values for solution.
# 
# Parameters
# B     : a matrix that stores the maximum values
# item  : number of subsets
# weight: weights
# S     : a matrix that stores pairs of weight and value of subsets
#
# Output: none

def knapsack(B, item, weight, S):
    # Outer loop for items 1...item
    for i in range(1, item+1):
        # Inner loop for weights 1...weight
        for j in range(1, weight+1):
            curWeight = S[i-1][0] # Weight of current item in S
            curValue = S[i-1][1] # Value of current item in S
            
            # Current item can be part of the solution
            if curWeight <= j:
                # Use current item's value for solution
                if curValue + B[i-1][j-curWeight] > B[i-1][j]:
                    B[i][j] = curValue + B[i-1][j-curWeight]
                # Do not use current item's value for solution
                else:
                    B[i][j] = B[i-1][j]
            # Current item is too big
            else:
                B[i][j] = B[i-1][j]
                
    
# Weight
w = 6
# Size of rows equals to weight
colSize = w

# Format of data.txt
# 3 25
# 2 20
# 1 15
# 4 40
# 5 50
f = open("data.txt", "r")
# Size of columns equals to number of subsets
rowSize = 0
for line in f:
    rowSize += 1
f.close()

# Create a matrix B which contains the maximum values for total weights up to indices, 
# and initialize every cell's value to 0
B = [[0 for x in range(colSize+1)] for y in range(rowSize+1)]

# Create a matrix S that stores pairs of weight and value of subsets
# S = [[3, 25],
#      [2, 20],
#      [1, 15],
#      [4, 40],
#      [5, 50]]
f = open("data.txt", "r")
S = [[int(n) for n in x.split(' ')] for x in f]
f.close()


# Implement knapsack algorithm
knapsack(B, rowSize, colSize, S)
# Optimal subset
optimalSubset = B[rowSize][colSize]

######### Answer for Problem 4.d #########
print("The optimal subset for this instance is: ${}".format(optimalSubset))



##=============================================================================
## 4.Extra Credit =============================================================

# =============================================================================
# This function find the composition of an optimal subset from the table
# generated by the bottom-up dynamic programming algorithm for the knapsack problem.
# 
# Parameters
# B     : a matrix that stores the maximum values
# item  : number of subsets
# weight: weights
# S     : a matrix that stores pairs of weight and value of subsets
# 
# Output: return the list containing the compositions

def findComposition(B, item, weight, S):
    j = weight 
    subsets = [] # list that stores a valid item
    
    for i in range(item, 0, -1):
        if B[i][j] > B[i-1][j]:      # Compare a current value to a value from previous row
            subsets.append(S[i-1])   # Store a item to list
            j -= S[i-1][0]           # Adjust weight by subtracting by item's weight
            if j == 0:               # 
                break

    return subsets
            
compositions = findComposition(B, rowSize, colSize, S)


######### Answer for problem 4.extra credit #########
print("The compositions of the optimal subset: {}".format(', '.join(str(x) for x in compositions)))


